#!/usr/bin/env zsh

fpath=(/usr/lib/zsh_libmisc/libmisc.zwc $fpath)
autoload libmiscinit
libmiscinit

input=$(fox-fr ./input)

isfile /tmp/dayeleven && \
  rm -rf /tmp/dayeleven/* && \
  rm -rf /tmp/dayeleven

isfile /tmp/dayeleven_tmp && \
  rm -rf /tmp/dayeleven_tmp/* && \
  rm -rf /tmp/dayeleven_tmp

mkdir /tmp/dayeleven
mkdir /tmp/dayeleven_tmp

create_worker() {
#  print "worker "$worker_id": got "$input" for input"
  polish_stone() {
    [ "$stone" = 0 ] && \
      print -n '1 ' && \
      return 0
    stoneln=$(getstrln "$stone")
    isevennum "$stoneln" && {
      haploid=$((stoneln/2))
      stoneleft=$((${stone: :$haploid}))
      stoneright=$((${stone:$haploid}))
      print -n ""$stoneleft" "$stoneright" "
      return 0
    }
    print -n ""$(($stone*2024))" " && \
      return 0
  }

  blinks=0
  while true; do
    blinks=$((blinks+1))
    placeholder=""
    IFS=$' '
    for stone in $=input; do
      placeholder=""$placeholder""$(polish_stone)""
    done
    unset IFS
    input=$placeholder
    [ "$blinks" = 15 ] && \
      break
  done
  print '' > /tmp/dayeleven_tmp/$worker_id
  print -n "$input" > /tmp/dayeleven/$worker_id
  return 0
}

print "pass 1/5"
## first pass (blinks=15)
worker_input_count=0
IFS=$' '
print "Starting workers..."
for distrib_input in $=input; do
  worker_input_count=$((worker_input_count+1))
  until worker_id=$worker_input_count input="$distrib_input" create_worker &; do
    wait
  done
done
unset IFS
print "finished start workers"
#wait_for_pass
until isfile /tmp/dayeleven_tmp/$worker_input_count; do
  sleep 1
done

## => 2nd pass
mo_passes() {
  print "combining worker outputs into next input"
  unset input
  worker_input_count=0
  rm -rf /tmp/dayelev/*
  rm -rf /tmp/dayelev
  cp -r /tmp/dayeleven /tmp/dayelev
  rm -rf /tmp/dayeleven/*
  rm -rf /tmp/dayeleven
  mkdir /tmp/dayeleven
  for do_recurse in /tmp/dayelev/*; do
    input=$(cat $do_recurse)
    IFS=$' '
    print "starting workers..."
    job_count=0
    for distrib_input in $=input; do
      worker_input_count=$((worker_input_count+1))
      job_count=$((job_count+1))
      [ "$job_count" = 99 ] && \
        wait && \
        job_count=0
      worker_id="$worker_input_count" input="$distrib_input" create_worker &
    done
    unset IFS
  done
  print "finished start workers"
}

do_until_passes=4
#set current pass to 1 since we already did one earlier
current_pass=1
while true; do
  print "pass "$((current_pass+1))"/5"
  mo_passes
  until isfile /tmp/dayeleven_tmp/$worker_input_count; do
    sleep 1
  done
  current_pass=$((current_pass+1))
  [ "$current_pass" -gt "$do_until_passes" ] && \
    break
done

print "counting final results"
final_total=0
for do_total_finally in /tmp/dayeleven/*; do
  final_input=$(cat $do_total_finally)
  IFS=$' '
  for thefinal_countdown in $=final_input; do
    final_total=$((1+final_total))
  done
  unset IFS
done
print "$final_total"
