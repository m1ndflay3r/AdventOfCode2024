#!/usr/bin/env zsh

# Initialize libmisc for 2d_arr support
fpath=(/usr/lib/zsh_libmisc/libmisc.zwc $fpath)
autoload libmiscinit
libmiscinit

# Normalize coordinates to grid size
normalize() {
  local coord=$1 size=$2
  local normalized=$(( coord % size ))
  (( normalized < 0 )) && normalized=$(( size + normalized ))
  echo $normalized
}

# Move robot for n steps
move_robot() {
  local robot="$1" n=$2 X=$3 Y=$4
  eval $robot
  local movedX=$(( x + n * vx ))
  local movedY=$(( y + n * vy ))
  movedX=$(normalize $movedX $X)
  movedY=$(normalize $movedY $Y)
  echo "x=$movedX y=$movedY vx=$vx vy=$vy"
}

# Determine quadrant after moving
quadrant_after_moving() {
  local robot="$1" n=$2 X=$3 Y=$4
  eval $(move_robot "$robot" $n $X $Y)
  if (( x < X / 2 )); then
    if (( y < Y / 2 )); then
      echo "topLeft"
    elif (( y > Y / 2 )); then
      echo "bottomLeft"
    else
      echo "none"
    fi
  elif (( x > X / 2 )); then
    if (( y < Y / 2 )); then
      echo "topRight"
    elif (( y > Y / 2 )); then
      echo "bottomRight"
    else
      echo "none"
    fi
  else
    echo "none"
  fi
}

# Calculate safety factor
part_one() {
  local -a robots=("${(@)1}")
  local -A quadrant_counts=(topLeft 0 topRight 0 bottomLeft 0 bottomRight 0)

  for robot in $robots; do
    local quadrant=$(quadrant_after_moving "$robot" 100 101 103)
    (( quadrant_counts[$quadrant]++ ))
  done

  local product=1
  for count in $quadrant_counts; do
    (( product *= count ))
  done
  echo $product
}

# Display robots on a 2D grid
display_robots() {
  local -a robots=("${(@)1}")
  local X=$2 Y=$3 arr_name="robot_grid"
  blank=1 2d_arr create $arr_name $X $Y  # Ensure blank array initialization
  for robot in $robots; do
    eval $robot
    2d_arr update $arr_name "#" $x $y  # Update grid with robot positions
  done
  2d_arr draw $arr_name          # Draw the grid to the terminal
  2d_arr delete $arr_name        # Cleanup after use
}

# Calculate Mean Absolute Deviation (MAD)
mad() {
  local -a values=("${(@)1}")
  local mean=0 sum=0
  for v in $values; do
    (( mean += v ))
  done
  mean=$(( mean / ${#values} ))

  for v in $values; do
    sum=$(( sum + abs(v - mean) ))
  done
  echo $(( sum / mean ))
}

# Part Two logic
part_two() {
  local -a robots=("${(@)1}")
  local X=101 Y=103 tXoffset=0 tYoffset=0

  # Step 1: Find vertical and horizontal grouping recurrence
  for t in {1..104}; do
    local -a new_positions
    for robot in $robots; do
      new_positions+=($(move_robot "$robot" $t $X $Y))
    done

    local -a x_positions y_positions
    for new_robot in $new_positions; do
      eval $new_robot
      x_positions+=$x
      y_positions+=$y
    done

    if (( $(mad $x_positions) < 0.35 )); then
      tXoffset=$t
    fi
    if (( $(mad $y_positions) < 0.35 )); then
      tYoffset=$t
    fi
    if (( tXoffset && tYoffset )); then
      break
    fi
  done

  # Step 2: Find the earliest timestep where both align
  for (( i = 0; ; i++ )); do
    local T_c=$(( tXoffset + i * X ))
    if (( (T_c - tYoffset) % Y == 0 )); then
      local -a final_positions
      for robot in $robots; do
        final_positions+=($(move_robot "$robot" $T_c $X $Y))
      done
      display_robots $final_positions $X $Y
      echo $T_c
      break
    fi
  done
}

# Load robot data from file
load_robots() {
  local file="$1"
  local -a robots
  mapfile -t lines < "$file"
  for line in $lines; do
    [[ $line =~ 'x=(-?[0-9]+),y=(-?[0-9]+) v=(-?[0-9]+),(-?[0-9]+)' ]]
    robots+=("x=${match[1]} y=${match[2]} vx=${match[3]} vy=${match[4]}")
  done
  echo $robots
}

# Main Program
main() {
  local file="$1"
  local -a robots=($(load_robots $file))

  # Part One
  local safety_factor=$(part_one $robots)
  echo "Safety Factor: $safety_factor"

  # Part Two
  part_two $robots
}

# Execute the program
main "$@"
